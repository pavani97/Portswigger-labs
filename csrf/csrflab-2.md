## Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF) is a web security vulnerability in which an attacker forces a victim’s browser to perform unintended actions on a web application where the victim is already authenticated.

To understand this better, consider the following scenario:

You are logged into your online banking account.

You unknowingly click a malicious link in an email or visit a compromised website.

That website silently sends a forged request to your bank from your browser.

Since your session is still active, the bank treats the request as legitimate.

As a result, sensitive actions such as changing account details or transferring money may be executed.

In this attack, the attacker never needs your credentials. Instead, they abuse the implicit trust that the application places in requests originating from an authenticated browser. It is similar to deceiving someone into signing a document without realizing its true purpose.

## CSRF Mitigation Techniques

Modern web applications employ several defenses to mitigate CSRF attacks, including:

CSRF Tokens

SameSite Cookie Attributes

Referer or Origin Header Validation

In this write-up, the focus is on CSRF tokens, how they work, and how insecure implementations can be bypassed.

## CSRF Tokens
Concept

A CSRF token is a unique, unpredictable value generated by the server and associated with a user’s session. This token is typically embedded within HTML forms as a hidden field or included in requests via headers or cookies.

Whenever a state-changing request is made, the server validates the token to ensure the request originated from the legitimate application and not from a third-party site.

Strengths

Highly effective when implemented correctly

Widely supported by modern frameworks

Protects against most CSRF attack vectors

Weaknesses

Vulnerable to bypass if token generation or validation is flawed

Incorrect assumptions about request methods can weaken protection

## Bypassing CSRF Tokens Based on Request Method
Vulnerability Overview

In some insecure implementations, CSRF token validation is enforced only for specific HTTP methods, most commonly POST requests. If the application fails to validate CSRF tokens for other methods such as GET, attackers can exploit this logic gap.

## Vulnerable Functionality Example

Consider a web application that allows users to update their email address after logging in.

When the user submits a new email address through the application interface, the request is sent using the POST method. Intercepting this request with Burp Suite Proxy reveals that a CSRF token is included and validated during the POST request.

At first glance, this appears secure.

## Crafting a CSRF Attack

The vulnerability becomes exploitable if the server does not enforce CSRF validation consistently across different request methods.

Using Burp Suite’s CSRF PoC Generator, a malicious HTML page can be created that automatically submits a forged request on behalf of the victim.

Steps Overview

Intercept the email change request in Burp Suite.

Right-click the request and navigate to Engagement Tools → Generate CSRF PoC.

Copy the generated HTML payload.

## Hosting the Malicious Page

To simulate a real-world attack scenario, the PortSwigger Academy Exploit Server can be used to host the malicious CSRF page.

Before deploying the payload:

Change the form’s request method from POST to GET

Remove the CSRF token parameter entirely

This modification helps determine whether the server validates CSRF tokens independently of the HTTP method.

If the server processes the request successfully without validating the token, the application is vulnerable to CSRF attacks caused by improper token enforcement.

## Key Takeaway

CSRF protection is only effective when:

Tokens are unpredictable

Tokens are validated on all state-changing requests

Validation is independent of the HTTP method used

A CSRF token that is conditionally validated offers a false sense of security and can be bypassed with minimal effort.
